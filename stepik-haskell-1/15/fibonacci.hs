-- Последовательность чисел Фибоначчи 0,1,1,2,3,5,8,13,21,…0,1,1,2,3,5,8,13,21,… 
-- легко определить рекурсивно, задав два первых терминирующих значения 
-- и определив любое последующее как сумму двух непосредственно предыдущих:
-- F0=0F0=0 
-- F1=1F1=1 
-- Fn=Fn−1+Fn−2Fn=Fn−1+Fn−2 

-- На Haskell данное определение задаётся следующей функцией:
-- fibonacci 0 = 0
-- fibonacci 1 = 1
-- fibonacci n = fibonacci (n - 1) + fibonacci (n - 2)

-- Эта функция определена лишь для неотрицательных чисел. 
-- Однако, из данного выше определения можно вывести формулу для вычисления чисел Фибоначчи 
-- при отрицательных индексах, при этом последовательность будет следующей:

-- F−1=1,F−2=−1,…,F−10=−55

-- Измените определение функции fibonacci так, чтобы она была определена для всех целых чисел 
-- и порождала при отрицательных аргументах указанную последовательность.

-- http://ru.math.wikia.com/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%A4%D0%B8%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D1%87%D0%B8
fibonacci x  | x == 0 = 0
            | x == 1 = 1
            | x > 1 = fibonacci (x - 1) + fibonacci (x - 2)
            | x < 0 && even (-x + 1) = fibonacci(-x)
            | x < 0 = - fibonacci(-x)


-- Реализация функции для вычисления числа Фибоначчи, основанная на прямом рекурсивном определении, 
-- крайне неэффективна - количество вызовов функции растет экспоненциально с ростом значения аргумента. 
-- GHCi позволяет отслеживать использование памяти и затраты времени на вычисление выражения, 
-- для этого следует выполнить команду :set +s:

-- GHCi> :set +s
-- GHCi> fibonacci 30
-- 832040
-- (8.36 secs, 298293400 bytes)

-- С помощью механизма аккумуляторов попробуйте написать более эффективную реализацию, 
-- имеющую линейную сложность (по числу рекурсивных вызовов). 
-- Как и в предыдущем задании, функция должна быть определена для всех целых чисел.

fibonacci' x  | x == 0 = 0
             | x == 1 = 1
             | x > 1 = helper 0 1 x
             | x < 0 && even (-x + 1) = fibonacci'(-x)
             | x < 0 = - fibonacci'(-x)

helper prev cur n | n == 1 = cur
                  | otherwise = helper cur (prev + cur) (n - 1)